module clixon-controller {
    yang-version 1.1;
    namespace "http://clicon.org/controller";
    prefix ctrl;
    import ietf-yang-types {
        prefix "yang";
    }
    import ietf-inet-types {
        prefix inet;
    }
    import ietf-netconf {
        prefix "nc";
    }
    import ietf-yang-schema-mount {
        prefix yangmnt;
    }
    import ietf-datastores {
        prefix ds;
    }
    import ietf-netconf-monitoring {
        prefix ncm;
    }
    import ietf-yang-library {
        prefix yanglib;
    }
    import ietf-netconf-acm {
        prefix nacm;
    }
    import clixon-lib {
        prefix cl;
    }
    import clixon-autocli {
        prefix autocli;
    }
    import clixon-restconf {
        prefix clrc; /* This pulls in top-level clrc:restconf */
    }
    description
        "Clixon controller";
    revision 2025-12-01 {
        description
            "Added service-timeout, differentiated from device timeout
             Released in 1.7.0";
    }
    revision 2025-08-01 {
        description
            "Added the following fields to device-common:
             - private-candidate
             - netconf-framing
             - netconf-state-schemas
             Released in 1.6.0";
    }
    revision 2025-05-01 {
        description
            "Added rpc device-rpc
             Released in 1.5.0";
    }
    revision 2025-02-01 {
        description
            "Added restconf
             Added common fields to transaction state and notification
             Added user to transaction
             Released in 1.4.0";
    }
    revision 2024-11-01 {
        description
             "Added device-group and changed input parameter devname to device in RPC:s:
                - config-pull
                - controller-commit
                - connection-change
                - get-device-config
                - datastore-diff
                - device-template-apply
              Added device-generic-rpc
              Added rpc-template
              Added rpc device-rpc-template-apply
              Added devices field to controller-transaction notification
              Added hide-show extension to created container
              Changed default device-common/port to 830
              Released in 1.3.0";
    }
    revision 2024-08-01 {
        description
             "Added device-domains
              Added port to device-common
              Changed mount-point label to device
              Released in 1.2.0";
    }
    revision 2024-04-01 {
        description
             "Added NACM
              Released in 1.1.0";
    }
    revision 2024-01-01 {
        description
            "Added warning field to transaction
             Added created-by-service grouping
             Added variables to templates
             Added service-instance parameter to rpc controller-commit
             Added ssh-stricthostkey
             Released in 1.0.0";
    }
    revision 2023-11-01 {
        description
            "Added device-profile list
             Added device-common grouping, for common device/device-profile fields
             Added module-set to device-common
             Changed rpc datastore-diff output to leaf-list
             Released in 0.2.0";
    }
    revision 2023-09-01 {
        description
            "Added identity services for NETCONF monitoring/transport
             Released in 0.1.0";
    }
    revision 2023-01-01 {
        description "Initial version";
    }
    identity actions {
        base ds:datastore;
        description
            "The actions datastore is used by service actions";
    }
    identity services {
        base ncm:transport;
        description
            "Services endpoint";
    }
    augment '/nc:get-config/input/source/config-source' {
        description
            "The actions datastore is used by service actions";
        leaf actions {
            type empty;
        }
    }
    augment '/nc:edit-config/input/target/config-target' {
        description
            "The actions datastore is used by service actions";
        leaf actions {
            type empty;
        }
    }
    /* augment: copy-config, delete-config */
    typedef connection-type{
        description
            "Which connection method to connect frm the controller to a device.
            ";
        type enumeration{
            enum NETCONF_SSH{
                description
                "NETCONF over SSH subsystem according to RFC 6242";
            }
        }
    }
    typedef yang-config{
        description
            "How to bind device configuration to YANG.";
        type enumeration{
            enum NONE {
                description
                  "Do not bind YANG to config
                   XXX not currently supported / required";
            }
            enum BIND {
                description
                "Bind YANG model to config, but do not fully validate
                 This corresponds to a sub-state in connection-state after DEVICE-SYNC";
            }
            enum VALIDATE {
                description "Fully validate device config";
            }
        }
    }
    typedef connection-state{
        description
            "Device connection state.
             The controller holds this connection state per device.";
        type enumeration{
            enum CLOSED {
                description
                "Not connected
                 Implicitly if no state exists for device, it is in CLOSED state";
            }
            enum OPEN {
                description  "Connection is open";
            }
            /* From here down INIT process */
            enum CONNECTING {
                description
                "Connection initiated: connect called
                 Expect to receive netconf hello from device
                 Transient state that timeout to CLOSED.
                 Connect failures include (1) connect fails or (2) hello not received";
            }
            enum SCHEMA_LIST {
                description
                  "Get ietf-netconf-monitoring schema for all YANG schemas,
                  Waiting for reply
                  Transient state that timeout to CLOSED.";
            }
            enum SCHEMA_ONE {
                description
                "Get-schema sent to device for each yang the device announces
                 Waiting for reply
                 Transient state that timeout to CLOSED.";
            }
            enum DEVICE-SYNC {
                description
                    "Hello received and hello sent to device,
                     If device announces monitoring a get-state on ietf-netconf-monitoring
                     is sent.
                    Transient state that timeout to CLOSED.";
            }
            /* From here down PUSH process. All these timeout to OPEN,
             * unless a un-recoverable error which timeouts to CLOSED
             */
            enum PUSH-CHECK {
                description  "Sync device transient to check if device is unchanged";
            }
            enum PUSH-EDIT {
                description  "Edit-config sent, waiting for reply";
            }
            enum PUSH-VALIDATE{
                description  "Validate sent, waiting for reply";
            }
            enum PUSH-COMMIT{
                description  "Commit sent, waiting for reply ok";
            }
            enum PUSH-COMMIT-SYNC{
                description  "Commit sent, waiting for reply ok";
            }
            enum PUSH-DISCARD{
                description  "Discard sent, waiting for reply";
            }
        }
    }
    typedef connection-operation{
        description
            "Device connection state.
             The controller holds this connection state per device.";
        type enumeration{
            enum CLOSE {
                description "Close connection";
            }
            enum OPEN {
                description "Open connection";
            }
            enum RECONNECT {
                description "Reconnect connection";
            }
        }
    }
    typedef transaction-state{
        description
            "Transaction state.";
        type enumeration{
            enum INIT {
                description "Started transaction";
            }
            enum ACTIONS {
                description "Notified and waiting for actions";
            }
            enum RESOLVED {
                description
                "The result of the transaction resolved.
                 Note that successful transactions are not in this state, they pass directly to closed,
                 while failed transactions use this state for error handling.";
            }
            enum DONE {
                description "Terminated, inactive transaction, with result";
            }
        }
    }
    typedef transaction-result{
        description
            "Transaction result as set in resolved and closed state.";
        type enumeration{
            enum INIT {
                description "Init state, no defined result";
            }
            enum ERROR {
                description "Transaction failed in an inconsistent state, not recoverable";
            }
            enum FAILED {
                description "Transaction failed but reverted successfully";
            }
            enum SUCCESS {
                description "Transaction completed successfully";
            }
        }
    }
    typedef device-config-type{
        description
            "Transaction configuration type.";
        type enumeration{
            enum RUNNING {
                description "Device config that the controller has in its running config";
            }
            enum CANDIDATE {
                description "Device config that the controller has in its candidate config";
            }
            enum ACTIONS {
                description "Device config that the controller has in its actions config";
            }
            enum SYNCED {
                description "Device config from last pull. A successful push also updates this config";
            }
            enum TRANSIENT {
                description
                   "The current configuration of the remote device.
                    Not saved on controller and only valid to the next device edit.";
            }
        }
    }
    typedef push-type {
        description
            "How to push configuration to devices.";
        type enumeration{
            enum NONE {
                description "Do not push to devices";
            }
            enum VALIDATE {
                description "Push to devices, validate and then discard on devices";
            }
            enum COMMIT {
                description "Push to devices, and commit on devices.";
            }
        }
    }
    typedef actions-type {
        description
            "How to trigger service-commit notifications, and thereby action scripts.";
        type enumeration{
            enum NONE {
                description "Do not trigger actions";
            }
            enum CHANGE {
                description
                "Trigger actions if service configuration has changed.
                 That is, if configuration of service A0 has changed, but not A1, then trigger
                 services-commit for service A0, but not A1";
            }
            enum FORCE {
                description
                "Unconditionally trigger services-commit notification for a service
                 or all services.";
            }
            enum DELETE {
                description
                "Delete service, remove service device data
                 XXX: bump yang revision number";
            }
        }
    }
    grouping created-by-service {
        description
            "All services should use this grouping for keeping track of created objects.";
        container created {
            description "List of created objects used by services.";
            autocli:hide-show;
            leaf-list path {
                description "Path to object";
                type string;
            }
        }
    }
    grouping device-common {
        description
            "Common fields for devices and device-profiles";
        leaf description{
            description
                "Description of device";
            type string;
        }
        leaf user{
            description
                "Which use to connect as to the device, if applicable";
            type string;
        }
        leaf conn-type{
            description
                "Connection type, eg how to connect to (or from) the device";
            type connection-type;
            default NETCONF_SSH;
        }
        leaf ssh-stricthostkey {
            when "../conn-type='NETCONF_SSH'";
            description
                "If 0, do not, if 1, ensure strict hostkey checking
                 Only for ssh connections";
            type boolean;
            default true;
        }
        leaf port {
            description
                "Transport port, typically for SSH.
                 RFC6242 stipulates a netconf subsystem over port 830,
                 in practice many devices can use port 22";
            type uint32;
            default 830;
        }
        leaf yang-config{
            description "How to bind device configuration to YANG.";
            type yang-config;
            default BIND;
        }
        container module-set {
            list module {
                key "name";
                description
                    "Yang schemas statically required for this device/profile.
                     Must exist on local storage accessible via the YANG_DIR options.
                     An entry in this list represents a module implemented by the
                     server, as per Section 5.6.5 of RFC 7950, with a particular
                     set of supported features and deviations.";
                uses yanglib:module-identification-leafs;
                leaf namespace {
                    type inet:uri;
                    mandatory true;
                    description
                        "The XML namespace identifier for this module.";
                }
            }
        }
        leaf device-domain {
            description
                "Isolated yang domain for YANGs in mountpoint.
                 Yang files will be in ${CLICON_YANG_DOMAIN_DIR}/${device-domain}";
            type string;
            default "default";
        }
        leaf private-candidate {
            description
                "Announce private-candidate capability to device in hello message";
            type boolean;
            default false;
        }
        leaf netconf-framing {
            description
                "How to announce netconf framing version to device in hello protocol
                 If not set, then announce both eom(base10) and chunked (base11).
                 If set to eom or chunked, then pin the value to only that and do not
                 announce the other";
            type cl:netconf-framing-type;
        }
        leaf netconf-state-schemas {
            description
                "Use ietf-netconf-monitoring to obtain YANG schemas from devices
                 using the netconf-state/schemas subtree as defined in RFC6022.
                 If false, yang modules can be specified via manual configuration of
                 module-set.
                 This does not effect using get-schema RPC to get schemas from the device";
            type boolean;
            default true;
        }
    }
    grouping device-template {
        description
            "Device templates provide a simple mechanism to apply a pre-set configuration
             part with a simple mechanism using variable substitution.
             A template is like a macro with shell-like ${var} variables.
             There are two uses: config and rpc.";
        leaf name{
            description
                "For rpc-template, this is the name of the RPC.";
            type string;
        }
        container variables {
            description "Formal variable declarations";
            list variable{
                description
                    "Formal variable template declaration.
                     Should match all instance of ${VAR} in the anydata config part.
                     Actual parameters are bound at apply time.
                     All variables are of type strings";
                key name;
                leaf name{
                    type string;
                }
                leaf description{
                    type string;
                }
            }
        }
        anydata config{
            description
                "Configuration template data with variable substitutions on the form ${var}.
                 For config templates, the template is supposed to be applied to a device/config mount-point.
                 For rpc templates, the first element is the rpc with its namespace.
                 The yang is unknown until applied";
        }
    }
    grouping device-choice {
        description "Choice of device or device-group patterns for RPC:s";
        choice devices {
            description "Specify devices with either name or group. None means all.";
            leaf device {
                description
                    "Name of device to push to, can use wildchars for several";
                type string;
            }
            leaf device-group {
                description
                    "Name of device-group, can use wildchars for several";
                type string;
            }
        }
    }
    grouping transaction-common {
        description "Common fields for transaction state and notification";
        leaf tid{
            description "Transaction id";
            type uint64;
        }
        leaf username{
            description "Which user created the transaction";
            type string;
        }
        leaf result {
            description "Transaction result";
            type transaction-result;
        }
        leaf reason {
            description "Reason for terminating transaction";
            type string;
        }
        container devices {
            list devdata {
                description
                    "Replies from device, can be rpc reply for rpc-template transaction";
                key name;
                leaf name{
                    description "device name, should be one of /devices/device/name";
                    type string;
                }
                anydata data {
                    description "Device reply data";
                }
            }
        }
    }
    container processes {
        description "Process configuration";
        container services {
            leaf enabled {
                description "If set, start services action daemon";
                type boolean;
                default true;
            }
        }
    }
    container services {
        description
            "Placeholder for services.
             This is typically augmented by an application, such as:
               import clixon-controller { prefix ctrl; }
               augment '/ctrl:services' {
                 list myservice {
                   key x;
                     leaf x {
                       type string;
                       ...
                     }
                   }
                 }
             Note 1: All augmented services must follow this layout (but not same names)
             Note 2: The alternative design:    services { list service { key name; ...}}
             does not work since augments would then act under service, and you want different
             services in different trees not in the same service branch.";
        leaf service-timeout{
            description
                "Service (action) daemon timeout in seconds.
                 When the backend issues a services-commit notification, it waits until a rpc transaction-actions-done
                 is received, and then continues with the transaction, specifically by updating devices.
                 If no such rpc is received within this timeout, a transaction error is sent using a
                 controller-transaction notification with result = ERROR
                 When the timeout occurs a syslog with level NOTICE is sent";
            type uint32;
            default 10;
            units s;
        }
        container properties {
        }
    }
    container devices{
        description "Device configuration";
        leaf device-timeout{
            description
                "Device transient state timeout in seconds, ie all states except 'open' and 'close'
                 Every time a device state is changed to a 'transient' state, this timer is set, if the device
                 has not left the state within this timeout, a transaction failure 'waiting for remote peer' will be
                 sent as a notification.";
            type uint32;
            default 60;
            units s;
        }
        list device-group{
            description "Groups of devices";
            key name;
            leaf name{
                type string;
            }
            leaf description{
                description
                    "Description of device-group";
                type string;
            }
            leaf-list device-name {
                description "Device within group";
                type leafref {
                    require-instance false;
                    path "/devices/device/name";
                }
            }
            leaf-list device-group {
                description
                   "A list of device groups contained in this device group.
                    Recursive definitions are not valid.";
                type leafref {
                  require-instance false;
                  path "/devices/device-group/name";
                }
            }
        }
        list device-profile {
            key name;
            leaf name{
                type string;
            }
            description
                "Device profile containing common config for devices.
                 A device can belong to one (or no) profile.
                 The fields in the profile are default values, that can be overridden
                 by fields given in the device section.";
            uses device-common;
        }
        list template {
            description
                "Configuration template";
            key name;
            uses device-template;
        }
        list rpc-template {
            description
                "RPC template";
            key name;
            uses device-template;
        }
        list device{
            key name;
            leaf name{
                description "device name";
                type string;
            }
            leaf enabled {
                type boolean;
                default true;
                description
                    "This leaf contains the configured, desired state of the device.
                     If false, a connection to the device is not attempted and
                     conn-state remains in CLOSED state.
                     If true, a connection to the device is attempted, striving to
                     reach the state OPEN";
            }
            leaf device-profile {
                description "Absolute references existing interfaces in if module";
                type leafref {
                    path "../../device-profile/name";
                    require-instance true;
                }
            }
            uses device-common;
            leaf device-type{
                description
                    "General-purpose field to characterize a device.
                     This is a freetext field for manual editing  where info such as
                     vendor, version etc could be added";
                type string;
            }
            leaf addr{
                description
                    "DNS name or ip address of device for connection setup (see also user)";
                mandatory true;
                type string;
            }
            /* From here, state data */
            leaf conn-state {
                description
                    "State of connection";
                config false;
                type connection-state;
                default CLOSED;
            }
            leaf conn-state-timestamp {
                description "Timestamp when entering current state";
                config false;
                type yang:date-and-time;
            }
            container capabilities {
                description
                    "May be duplicate if netconf-monitoring is implemented?";
                config false;
                leaf-list capability {
                    type string;
                    description
                        "List of NETCONF capabilities supported by the server.";
                }
            }
            leaf sync-timestamp {
                description "Timestamp of last device synchronization";
                config false;
                type yang:date-and-time;
            }
            leaf logmsg {
                config false;
                type string;
            }
            leaf private-candidate-state {
                description
                    "State of private-candidate after capability negotiation";
                config false;
                type boolean;
            }
            leaf netconf-framing-type {
                description
                    "State of netconf-framing after capability negotiation";
                config false;
                type cl:netconf-framing-type;
            }
            container config {
                presence "Otherwise root is not visible";
                description
                    "Mount-point for device configs";
                yangmnt:mount-point "device"{
                    description
                       "Root for yang models retrieved from device via get-schema";
                }
                cl:xmldb-split {
                    description "Multi-XMLDB: split datastore here";
                }
            }
        }
    }
    container transactions {
        config false;
        description
            "Info about clixon controller device transaction.
             A controller transaction spans commits on the controller as well as device actions,
             such as pushing edits, validate, and commit of device configs.
             See also notification controller-transaction";
        list transaction {
            description "Transaction info";
            key tid;
            uses transaction-common;
            leaf state {
                description "Transaction state";
                type transaction-state;
            }
            leaf description {
                description "Description of transaction";
                type string;
            }
            leaf origin {
                description "Originator of error";
                type string;
            }
            leaf warning {
                description "Warning, first encountered";
                type string;
            }
            leaf timestamp {
                description "Timestamp when entering current state";
                type yang:date-and-time;
            }
        }
    }
    /* List of config false creator attributes */
    notification services-commit {
        description
            "A commit has been made that changes the services declaration and
             that triggers services script.
             NOTE: A check is made that only one such registration is active.";
        leaf tid {
            description "Transaction id that this commit is a part of";
            type uint64;
        }
        leaf source {
            description
                "Source datastore for actions, where to read configurations of services and devices";
            type ds:datastore-ref;
            default ds:candidate;
        }
        leaf target {
            description
                "target datastore for actions, where to write configurations of devices";
            type ds:datastore-ref;
            default actions;
        }
        leaf-list service {
            description
                "Names of service/instance that have changed configuration.
                Or should be reapplied.
                None means all (eg reapply unconditionally)
                Two formats:
                   - <service>/<instance>
                   - <service>   applies to all instances ina  service";
            type string;
        }
	leaf diff {
	    description "Diff of the services configuration";
	    type boolean;
	    default false;
	}
    }
    notification controller-transaction {
        description
            "A transaction has been completed.
             See also non-config transaction container";
        uses transaction-common;
    }
    rpc config-pull {
        description
            "Read(pull) the config of one or several devices.
             The pulled config is either:
             - cached as device-<devname>-SYNCED.xml and committed as master OR
             - cached as device-<devname>-TRANSIENT.xml (not installed)";
        input {
            uses device-choice {
                description "Specify devices with either name or group pattern.";
            }
            leaf merge {
                description
                    "If false, replace the local device configuration with the
                     remote (actual) device config.
                     If true, merge the remote device configuration with the local
                     device configuration.";
                type boolean;
                default false;
            }
            leaf transient {
                description
                    "Get the device config but do not install it";
                type boolean;
                default false;
            }
        }
        output {
            leaf tid {
                description "Transaction id allocated";
                type uint64;
            }
        }
    }
    rpc controller-commit {
        description
            "Extended commit: trigger actions and device push.
             There are many variants of this RPC determined by its input parameters:
             - device selection
             - datastore source
             - actions parameter
             - push parameter
             The following combinations will return error:
             1) If no devices are selected UNLESS no remote validate/commit is made
                You may want to dryrun a service for example even if no devices are present
             2) If local device fields are changed (except device mount-point - 'config')
                These may potentially effect the device connection and should be made
                using regular netconf local commit followed by rpc connection-change.
             3) A device is CLOSED UNLESS no remote validate/commit is made
                which means you can do local operations (like diff) even when devices are down
             Further:
             4) Avoid doing BOTH local and remote edits simultaneously
                The system detects local edits (see 2) but if one instead uses local commit,
                the remote edits need to be explicitly pushed
             Note that:
             - a PUSH is done even though no changes are detected on that device
             - An error is returned if a change is detected on a device that is closed
            ";
        input {
            uses device-choice {
                description
                    "Specify devices with either name or group pattern.
                     If none given, assume all";
            }
            leaf source {
                description
                    "Source datastore for controller commit
                     If actions is enabled, it is the source of actions
                     Otherwise it is the source for push which is candidate or running
                     If candidate a controller commit is made at end of operation.,
                     Note that the common datastores typically have prefix ds:, like ds:running
                     and there may be a need to strip the prefix for other uses";
                type ds:datastore-ref;
                default ds:running;
            }
            leaf actions {
                description
                    "Trigger actions from candidate into action-db.
                     Normally actions are triggered only if service configs have changed.
                     However, this can be overriden by setting force-actions to true.";
                type actions-type;
                default NONE;
            }
            leaf push {
                description
                    "How to push configuration diffs to devices.
                     Diffs are computed from the last SYNCED device datastore.
                     If actions is enabled the source datastore of push is action-db
                     Otherwise the source is the value of datastore.
                     If push is COMMIT and the push is successful,
                     a local controller commit is made as follows:
                     - if actions, commit is made from action-db
                     - otherwise if datastore is candidate, commit is made from candidate
                     - otherwise, no commit is made
                     ";
                type push-type;
                default NONE;
            }
            leaf service-instance {
                when "../actions = 'FORCE' or ../actions = 'DELETE'";
                description
                    "For forced reapply select which service-instance should be triggered";
                type string;
            }
        }
        output {
            leaf tid {
                description "Id of allocated transaction, use for notification";
                type uint64;
            }
        }
    }
    rpc connection-change {
        description
            "(Re)connect try an enabled device in CLOSED state.
             If closed due to error it may need to be cleared and reconnected.";
        input {
            uses device-choice {
                description "Specify devices with either name or group pattern.";
            }
            leaf operation {
                description "close, open, reconnect";
                type connection-operation;
                default 0;
            }
        }
        output {
            leaf tid {
                description "Id of allocated transaction, use for notification";
                type uint64;
            }
        }
    }
    rpc get-device-config {
        description
            "Get configuration db of a single device of name 'device-<devname>-<postfix>.xml'
             With-default mode is 'explicit'
             Typically this db is retrieved by the pull rpc
             Should probably be replaced by a more generic function.
             Possibly just extend get-config with device dbs?";
        input {
            uses device-choice {
                description "Specify devices with either name or group pattern.";
            }
            leaf config-type{
                description "Device config type";
                type device-config-type;
                mandatory true;
            }
        }
        output {
            anydata config {
                description "Device configuration";
            }
        }
    }
    rpc transaction-error {
        description
            "Terminate an ongoing transaction with an error condition.";
        input {
            leaf tid {
                type uint64;
                description "Transaction id";
                mandatory true;
            }
            leaf origin {
                description "Originator of error";
                type string;
            }
            leaf reason {
                description "Reason for terminating transaction";
                type string;
                mandatory true;
            }
        }
    }
    rpc transaction-actions-done {
        description
            "Action scripts signal to backend that all actions are completed";
        input {
            leaf tid {
                description "Transaction is used in notification";
                type uint64;
                mandatory true;
            }
        leaf-list service {
            type string;
            description
                "Names of services that have been processed/served by this action (S1).
                 This should be a subset of the services list in the services-commit notification S0.
                 In case the S0 was NULL, it meant all services, and this list contains the list
                 that were actually served.
                 The operation of an action is:
                   Remove all services in S0 that are not served by this action: -> S1
                   For all S in S1:
                     Process service actions for S resulting in a set of edit-configs (possibly none)
                   Append S1 to transactions-actions-done rpc";
            }
        }
    }
    rpc datastore-diff {
        description
            "Compare two data-stores by returning a diff-list in XML.
             There are two variants:
             1) Regular datastore references, such as running/candidate according to
                ietf-datastores YANG
             2) Clixon-controller specific device datastores";
        input {
            leaf xpath {
                description
                    "XPath to part of XML to compare.
                     Only when datastore = reference";
                type string;
            }
            leaf format {
                type cl:datastore_format;
                default xml;
            }
            choice datastore {
                description
                    "First datastore to compare";
                case reference{
                    leaf dsref1 {
                        description
                            "First datastore to compare";
                        type ds:datastore-ref;
                    }
                    leaf dsref2 {
                        description
                            "Second datastore to compare";
                        type ds:datastore-ref;
                    }
                }
                case device{
                    uses device-choice {
                        description "Specify devices with either name or group pattern.";
                    }
                    leaf config-type1{
                        description "Device config type";
                        type device-config-type;
                    }
                    leaf config-type2{
                        description "Device config type";
                        type device-config-type;
                    }
                }
                mandatory true;
            }
        }
        output {
            leaf-list diff {
                description "Pretty-printed diff strings";
                type string;
            }
        }
    }
    rpc device-template-apply {
        description "Apply device templates on device configure";
        input {
            leaf type {
                description
                    "Device template type";
                type enumeration{
                    enum CONFIG{
                        description
                        "Device configuration template";
                    }
                    enum RPC{
                        description
                        "Device RPC template";
                    }
                }
                default CONFIG;
            }
            uses device-choice {
                description "Specify devices with either name or group pattern.";
            }
            choice template {
                leaf template {
                    description
                        "Name of device template.";
                    type leafref {
                        path "/devices/template/name";
                        require-instance false;
                    }
                }
                container inline {
                    uses device-template;
                }
            }
            container variables {
                description "variable bindings";
                list variable {
                    key name;
                    leaf name {
                        type string;
                    }
                    leaf value {
                        type string;
                    }
                }
            }
        }
        output {
            choice template-reply {
                description
                    "Different replies depending on template type";
                leaf tid {
                    description
                        "Id of allocated transaction, for RPC templates";
                    type uint64;
                }
                leaf ok {
                    description
                        "Direct reply";
                    type empty;
                }
            }
        }
    }
    rpc device-rpc {
        description
            "Send RPC to devices";
        input {
            leaf sync{
                type boolean;
                description
                    "1: sync: block until result (only available via restconf)
                     0: async, return transaction-id";
            }
            uses device-choice {
                description "Specify devices with either name or group pattern.";
            }
            anydata config{
                description
                    "The first element is the rpc with its namespace.
                     The yang is unknown until applied
                     Example:
                       <config>
                         <get xmlns='urn:ietf:params:xml:ns:netconf:base:1.0'/>
                       </config>";
            }
        }
        output {
            choice rpc-reply {
                description
                    "blocking reply for sync, transaction-id for async";
                case async{
                    leaf tid {
                        description
                            "Id of allocated transaction, for RPC templates";
                        type uint64;
                    }
                }
                case sync{
                    container devices {
                        list devdata {
                            description
                                "Replies from device, can be rpc reply for rpc-template transaction";
                            key name;
                            leaf name{
                                description "device name, should be one of /devices/device/name";
                                type string;
                            }
                            anydata data {
                                description "Device reply data";
                            }
                        }
                    }
                }
            }
        }

    }
}
